#!/bin/sh
# TODO: write all this shit in C

set -eu

EMACSD_STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/emacsd"
EMACSD_CURRENT_LOGFILE="$EMACSD_STATE_DIR/.emacsd-current.log"
EMACSD_START_LOCKFILE="$EMACSD_STATE_DIR/.emacsd-start.lock"
[ -d "$EMACSD_STATE_DIR" ] || mkdir -p "$EMACSD_STATE_DIR"

EMACSD_START_TIMEOUT="${EMACSD_START_TIMEOUT:-5}"             # guaranteed minimum wait in secs
EMACSD_START_HARDCAP="${EMACSD_START_HARDCAP:-900}"           # absolute max wait in secs
EMACSD_START_INTERVAL="${EMACSD_START_INTERVAL:-0.2}"         # poll interval in secs
EMACSD_LOG_STALE_TIMEOUT="${EMACSD_LOG_STALE_TIMEOUT:-12}"    # extends while logs fresh in secs

EMACSD_STOP_TIMEOUT="${EMACSD_STOP_TIMEOUT:-12}"      # absolute max wait in secs
EMACSD_STOP_INTERVAL="${EMACSD_STOP_INTERVAL:-0.2}"   # poll interval in secs

EMACSD_NATIVE_COMP_WATCH_TIMEOUT=${EMACSD_NATIVE_COMP_WATCH_TIMEOUT:-20}      # keep watching for n secs
EMACSD_NATIVE_COMP_WATCH_INTERVAL="${EMACSD_NATIVE_COMP_WATCH_INTERVAL:-5}"   # interval between sweeps in secs
EMACSD_NATIVE_COMP_AGE_THRESHOLD="${EMACSD_NATIVE_COMP_AGE_THRESHOLD:-10}"    # max age in secs
EMACSD_NATIVE_COMP_KILL_GRACE="${EMACSD_NATIVE_COMP_KILL_GRACE:-2}"           # time to die in sec

usage() {
  cat << EOF
usage: emacsd {start/up|stop/down|restart|status|logs|version|help}

commands:
  start|up    start emacs daemon
  stop|down   stop the running emacs daemon
  restart     restart the running emacs daemon
  status      show daemon status, pid, version and log path
  logs        manage daemon logs
    show      show daemon logs
      -f      follow logs
    clean     delete all logfiles (except the current, if daemon is running)
  version     print emacsd version
  help        show this help
EOF
}

version() {
  echo "emacsd - v0.1.0"
}

is_emacs_daemon_process_open() {
  pgrep -f -u "$(id -u -n)" "[e]macs --fg-daemon" > /dev/null 2>&1
}

is_running() {
  emacsclient -e 't' >/dev/null 2>&1
}

pid() {
  emacsclient -e '(emacs-pid)'
}

exit_emacs() {
  has_unsaved=$(emacsclient -e \
    '(if (seq-some (lambda (b)
                     (and (buffer-file-name b) (buffer-modified-p b)))
                   (buffer-list)) 1 0)' 2> /dev/null)

  if [ "$has_unsaved" -eq 1 ]; then
    echo "you have unsaved work, resolve this first"
    exited=$(emacsclient -n -r -e \
      '(progn
         (select-frame-set-input-focus (selected-frame))
         (save-buffers-kill-emacs))' 2> /dev/null)

    if [ -z "$exited" ]; then
      return 0
    else
      echo "user aborted the shutdown"
      return 1
    fi
  fi

  emacsclient -e '(kill-emacs)' > /dev/null 2>&1
}

log_no_stdout() {
  echo "$(date '+%F %T') emacsd: $1" >> "$EMACSD_CURRENT_LOGFILE"
}

log() {
  echo "$1"
  log_no_stdout "$1"
}

prune_logs() {
  set -- "$EMACSD_STATE_DIR"/emacsd*.log

  if [ "$#" -ge 10 ]; then
    to_remove=$(ls -1 "$EMACSD_STATE_DIR"/emacsd*.log | head -n -9)
    echo "more than 10 logfiles, going to remove $(basename "$to_remove")"
    rm -f "$to_remove"
    echo "removed $(basename "$to_remove") successfully"
  fi
}

clean_logs() {
  if ! is_running; then
    rm -f "$EMACSD_STATE_DIR"/*.log "$EMACSD_CURRENT_LOGFILE"
    return 0
  fi

  fd -d1 -tf -E "emacsd*-$(pid).log" . "$EMACSD_STATE_DIR" -X rm -f
}

show_logs() {
  if [ ! -f "$EMACSD_CURRENT_LOGFILE" ]; then
    echo "no logs to show"
    return 1
  fi

  bat --language=log --style=numbers "$EMACSD_CURRENT_LOGFILE"
}

follow_logs() {
  if [ ! -f "$EMACSD_CURRENT_LOGFILE" ]; then
    echo "no logs to follow"
    return 1
  fi

  tail -F -n +1 "$EMACSD_CURRENT_LOGFILE" 2> /dev/null \
    | bat --paging=never --language=log --style=numbers
}

is_log_fresh() {
  [ -f "$EMACSD_CURRENT_LOGFILE" ] || return 1

  age=$(( $(date +%s) - $(stat -L -c %Y "$EMACSD_CURRENT_LOGFILE" 2> /dev/null)))
  [ "$age" -le "$EMACSD_LOG_STALE_TIMEOUT" ]
}

unlock_start_lock() {
  flock -u 9 2> /dev/null || :; exec 9>&- 2> /dev/null || :
}

reap_stuck_native_comp() {
  pid="$(pid)" || return 0
  [ -n "$pid" ] || return 0
  log_no_stdout "started reap_stuck_native_comp watcher for emacs daemon $pid"

  watch_start="$(date +%s)"

  while :; do
    if ! is_running; then
      log_no_stdout "emacs daemon $pid is not running anymore, stopping reap_stuck_native_comp watcher"
      return 0
    fi

    if [ $(( $(date +%s) - watch_start )) -ge "$EMACSD_NATIVE_COMP_WATCH_TIMEOUT" ]; then
      log_no_stdout "finished reap_stuck_native_comp watching process for emacs daemon $pid"
      return 0
    fi

    for ncp in $(pgrep -u "$(id -u -n)" -f '/usr/bin/emacs.*-no-comp-spawn.*-Q.*--batch'); do
      ppid="$(ps -o ppid= -p "$ncp" 2> /dev/null | tr -d ' ')"
      [ "$ppid" = "$pid" ] || continue

      et="$(ps -o etimes= -p "$ncp" 2> /dev/null | tr -d ' ')"
      [ -n "$et" ] || continue

      if [ "$et" -ge "$EMACSD_NATIVE_COMP_AGE_THRESHOLD" ]; then
        log_no_stdout "reaping stuck native compilation pid: $ncp, age: ${et}s for emacs daemon $pid"
        kill "$ncp" 2> /dev/null || true
        sleep "$EMACSD_NATIVE_COMP_KILL_GRACE"
        kill -0 "$ncp" 2> /dev/null && kill -9 "$ncp" 2> /dev/null || true
        log_no_stdout "successfully reaped stuck native compilation pid: $ncp, age: ${et}s for emacs daemon $pid"
      fi
    done

    sleep "$EMACSD_NATIVE_COMP_WATCH_INTERVAL"
  done
}

start() {
  if is_running; then
    echo "emacsd already running"
    return 1
  fi

  exec 9> "$EMACSD_START_LOCKFILE" || :
  if ! flock -n 9; then
    echo "another emacsd start is in progress"
    unlock_start_lock
    return 1
  fi

  trap 'unlock_start_lock' EXIT INT TERM HUP

  logfile_ts="$(date +%Y%m%d%H%M%S)"
  logfile="$EMACSD_STATE_DIR/emacsd-$logfile_ts.log"
  prune_logs
  ln -sf "$logfile" "$EMACSD_CURRENT_LOGFILE"

  log "starting emacsd"
  setsid -f sh -c '/usr/bin/emacs --fg-daemon --chdir="'"$HOME"'" < /dev/null 2>&1 \
    | while IFS= read -r l; do echo "$(date "+%F %T") emacs: $l"; done >> "'"$EMACSD_CURRENT_LOGFILE"'"' \
    > /dev/null 2>&1 < /dev/null &

  soft_deadline=$(( $(date +%s) + ${EMACSD_START_TIMEOUT%.*} ))
  hard_deadline=$(( $(date +%s) + ${EMACSD_START_HARDCAP%.*} ))

  while :; do
    if is_running; then
      new_logfile="$EMACSD_STATE_DIR/emacsd-$logfile_ts-$(pid).log"
      mv -f "$logfile" "$new_logfile"
      ln -sf "$new_logfile" "$EMACSD_CURRENT_LOGFILE"

      log "started emacsd"
      trap - EXIT INT TERM HUP
      unlock_start_lock
      nohup "$0" __reap-stuck-native-comp < /dev/null > /dev/null 2>&1 &
      return 0
    fi

    now="$(date +%s)"
    if [ "$now" -ge "$soft_deadline" ]; then
      if [ "$now" -ge "$hard_deadline" ] || { ! is_emacs_daemon_process_open && ! is_log_fresh; }; then
        break;
      fi
    fi

    sleep "$EMACSD_START_INTERVAL"
  done

  log "failed to start emacsd"
  echo "see logs at $(readlink -f "$EMACSD_CURRENT_LOGFILE")"
  trap - EXIT INT TERM HUP
  unlock_start_lock
  return 1
}

stop() {
  if ! is_running; then
    echo "emacsd not running"
    return 1
  fi

  log "stopping emacsd"

  if ! exit_emacs; then
    log "failed to request emacs shutdown"
    return 1
  fi

  deadline=$(( $(date +%s) + ${EMACSD_STOP_TIMEOUT%.*} ))
  while :; do
    if ! is_running; then
      log "stopped emacsd"
      return 0
    fi

    [ "$(date +%s)" -ge "$deadline" ] && break
    sleep "$EMACSD_STOP_INTERVAL"
  done

  log "failed to stop emacsd"
  echo "see logs at $(readlink -f "$EMACSD_CURRENT_LOGFILE")"
  return 1
}

restart() {
  if ! is_running; then echo "emacsd not running"; return 1; fi
  stop
  start
}

status() {
  if is_running; then
    echo "emacsd: up"
    echo "pid: $(pid)"
    emacsclient -e '(format "version: %s" emacs-version)' | tr -d '"'
    echo "log: $(readlink -f "$EMACSD_CURRENT_LOGFILE")"
  else
    echo "emacsd: down"
  fi
}

cmd="${1-}"
case "$cmd" in
  start|up) start;;
  stop|down) stop;;
  restart) restart;;
  status) status;;
  logs)
    shift
    cmd="${1-}"
    case "$cmd" in
      show)
        shift
        flag="${1-}"
        case "$flag" in
          -f) follow_logs;;
          "") show_logs;;
          *) echo "unknown flag: $flag"; usage; exit 1;;
        esac;;
      "") show_logs;;
      -f) follow_logs;;
      clean) clean_logs;;
      *) echo "unknown argument: $cmd"; usage; exit 1;;
    esac;;
  version) version;;
  help) usage;;
  __reap-stuck-native-comp) reap_stuck_native_comp;;
  "") usage; exit 1;;
  *) echo "unknown argument: $cmd"; usage; exit 1;;
esac
